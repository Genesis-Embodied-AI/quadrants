quadrants.lang.snode
====================

.. py:module:: quadrants.lang.snode


Classes
-------

.. autoapisummary::

   quadrants.lang.snode.SNode


Functions
---------

.. autoapisummary::

   quadrants.lang.snode.rescale_index
   quadrants.lang.snode.append
   quadrants.lang.snode.is_active
   quadrants.lang.snode.activate
   quadrants.lang.snode.deactivate
   quadrants.lang.snode.length
   quadrants.lang.snode.get_addr


Module Contents
---------------

.. py:class:: SNode(ptr: quadrants._lib.core.quadrants_python.SNodeCxx)

   A Python-side SNode wrapper.

   For more information on Quadrants's SNode system, please check out
   these references:

   * https://docs.taichi-lang.org/docs/sparse
   * https://yuanming.quadrants.graphics/publication/2019-quadrants/quadrants-lang.pdf

   Arg:
       ptr (pointer): The C++ side SNode pointer.


   .. py:attribute:: ptr


   .. py:method:: dense(axes: list[quadrants._lib.core.quadrants_python.Axis], dimensions: list[int] | int) -> SNode

      Adds a dense SNode as a child component of `self`.

      :param axes: Axes to activate.
      :type axes: List[Axis]
      :param dimensions: Shape of each axis.
      :type dimensions: Union[List[int], int]

      :returns: The added :class:`~quadrants.lang.SNode` instance.



   .. py:method:: pointer(axes: list[quadrants._lib.core.quadrants_python.Axis], dimensions: list[int] | int) -> SNode

      Adds a pointer SNode as a child component of `self`.

      :param axes: Axes to activate.
      :type axes: List[Axis]
      :param dimensions: Shape of each axis.
      :type dimensions: Union[List[int], int]

      :returns: The added :class:`~quadrants.lang.SNode` instance.



   .. py:method:: dynamic(axis: list[quadrants._lib.core.quadrants_python.Axis], dimension: int, chunk_size: int | None = None) -> SNode

      Adds a dynamic SNode as a child component of `self`.

      :param axis: Axis to activate, must be 1.
      :type axis: List[Axis]
      :param dimension: Shape of the axis.
      :type dimension: int
      :param chunk_size: Chunk size.
      :type chunk_size: int

      :returns: The added :class:`~quadrants.lang.SNode` instance.



   .. py:method:: bitmasked(axes: list[quadrants._lib.core.quadrants_python.Axis], dimensions: list[int] | int) -> SNode

      Adds a bitmasked SNode as a child component of `self`.

      :param axes: Axes to activate.
      :type axes: List[Axis]
      :param dimensions: Shape of each axis.
      :type dimensions: Union[List[int], int]

      :returns: The added :class:`~quadrants.lang.SNode` instance.



   .. py:method:: quant_array(axes: list[quadrants._lib.core.quadrants_python.Axis], dimensions: list[int] | int, max_num_bits: int) -> SNode

      Adds a quant_array SNode as a child component of `self`.

      :param axes: Axes to activate.
      :type axes: List[Axis]
      :param dimensions: Shape of each axis.
      :type dimensions: Union[List[int], int]
      :param max_num_bits: Maximum number of bits it can hold.
      :type max_num_bits: int

      :returns: The added :class:`~quadrants.lang.SNode` instance.



   .. py:method:: place(*args, offset: numbers.Number | tuple[numbers.Number] | None = None) -> SNode

      Places a list of Quadrants fields under the `self` container.

      :param \*args: A list of Quadrants fields to place.
      :type \*args: List[ti.field]
      :param offset: Offset of the field domain.
      :type offset: Union[Number, tuple[Number]]

      :returns: The `self` container.



   .. py:method:: lazy_grad()

      Automatically place the adjoint fields following the layout of their primal fields.

      Users don't need to specify ``needs_grad`` when they define scalar/vector/matrix fields (primal fields) using autodiff.
      When all the primal fields are defined, using ``quadrants.root.lazy_grad()`` could automatically generate
      their corresponding adjoint fields (gradient field).

      To know more details about primal, adjoint fields and ``lazy_grad()``,
      please see Page 4 and Page 13-14 of DiffQuadrants Paper: https://arxiv.org/pdf/1910.00935.pdf



   .. py:method:: lazy_dual()

      Automatically place the dual fields following the layout of their primal fields.



   .. py:method:: parent(n=1)

      Gets an ancestor of `self` in the SNode tree.

      :param n: the number of levels going up from `self`.
      :type n: int

      :returns: The n-th parent of `self`.
      :rtype: Union[None, _Root, SNode]



   .. py:property:: shape

      Gets the number of elements from root in each axis of `self`.

      :returns: The number of elements from root in each axis of `self`.
      :rtype: Tuple[int]


   .. py:method:: deactivate_all()

      Recursively deactivate all children components of `self`.



.. py:function:: rescale_index(a, b, I)

   Rescales the index 'I' of field (or SNode) 'a' to match the shape of SNode 'b'.

   :param a: Input quadrants fields or snodes.
   :type a: Union[:class:`~quadrants.Field`, :class:`~quadrants.MatrixField`
   :param b: Input quadrants fields or snodes.
   :type b: Union[:class:`~quadrants.Field`, :class:`~quadrants.MatrixField`
   :param I: grouped loop index.
   :type I: Union[list, :class:`~quadrants.Vector`]

   :returns: rescaled grouped loop index
   :rtype: Ib (:class:`~quadrants.Vector`)


.. py:function:: append(node, indices, val)

   Append a value `val` to a SNode `node` at index `indices`.

   :param node: Input SNode.
   :type node: :class:`~quadrants.SNode`
   :param indices: the indices to visit.
   :type indices: Union[int, :class:`~quadrants.Vector`]
   :param val: the data to be appended.
   :type val: Union[:mod:`~quadrants.types.primitive_types`, :mod:`~quadrants.types.compound_types`]


.. py:function:: is_active(node, indices)

   Explicitly query whether a cell in a SNode `node` at location
   `indices` is active or not.

   :param node: Must be a pointer, hash or bitmasked node.
   :type node: :class:`~quadrants.SNode`
   :param indices: the indices to visit.
   :type indices: Union[int, list, :class:`~quadrants.Vector`]

   :returns: the cell `node[indices]` is active or not.
   :rtype: bool


.. py:function:: activate(node, indices)

   Explicitly activate a cell of `node` at location `indices`.

   :param node: Must be a pointer, hash or bitmasked node.
   :type node: :class:`~quadrants.SNode`
   :param indices: the indices to activate.
   :type indices: Union[int, :class:`~quadrants.Vector`]


.. py:function:: deactivate(node, indices)

   Explicitly deactivate a cell of `node` at location `indices`.

   After deactivation, the Quadrants runtime automatically recycles and zero-fills
   the memory of the deactivated cell.

   :param node: Must be a pointer, hash or bitmasked node.
   :type node: :class:`~quadrants.SNode`
   :param indices: the indices to deactivate.
   :type indices: Union[int, :class:`~quadrants.Vector`]


.. py:function:: length(node, indices)

   Return the length of the dynamic SNode `node` at index `indices`.

   :param node: a dynamic SNode.
   :type node: :class:`~quadrants.SNode`
   :param indices: the indices to query.
   :type indices: Union[int, :class:`~quadrants.Vector`]

   :returns: the length of cell `node[indices]`.
   :rtype: int


.. py:function:: get_addr(f, indices)

   Query the memory address (on CUDA/x64) of field `f` at index `indices`.

   Currently, this function can only be called inside a quadrants kernel.

   :param f: Input quadrants field for memory address query.
   :type f: Union[:class:`~quadrants.Field`, :class:`~quadrants.MatrixField`]
   :param indices: The specified field indices of the query.
   :type indices: Union[int, :class:`~quadrants.Vector`]

   :returns: The memory address of `f[indices]`.
   :rtype: ti.u64



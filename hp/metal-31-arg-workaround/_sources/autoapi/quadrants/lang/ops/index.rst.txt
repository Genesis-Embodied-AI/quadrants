quadrants.lang.ops
==================

.. py:module:: quadrants.lang.ops


Functions
---------

.. autoapisummary::

   quadrants.lang.ops.cast
   quadrants.lang.ops.bit_cast
   quadrants.lang.ops.sin
   quadrants.lang.ops.cos
   quadrants.lang.ops.asin
   quadrants.lang.ops.acos
   quadrants.lang.ops.sqrt
   quadrants.lang.ops.rsqrt
   quadrants.lang.ops.round
   quadrants.lang.ops.floor
   quadrants.lang.ops.ceil
   quadrants.lang.ops.frexp
   quadrants.lang.ops.tan
   quadrants.lang.ops.tanh
   quadrants.lang.ops.exp
   quadrants.lang.ops.log
   quadrants.lang.ops.abs
   quadrants.lang.ops.random
   quadrants.lang.ops.pow
   quadrants.lang.ops.atan2
   quadrants.lang.ops.raw_div
   quadrants.lang.ops.raw_mod
   quadrants.lang.ops.bit_shr
   quadrants.lang.ops.select
   quadrants.lang.ops.atomic_add
   quadrants.lang.ops.atomic_mul
   quadrants.lang.ops.atomic_sub
   quadrants.lang.ops.atomic_min
   quadrants.lang.ops.atomic_max
   quadrants.lang.ops.atomic_and
   quadrants.lang.ops.atomic_or
   quadrants.lang.ops.atomic_xor
   quadrants.lang.ops.max
   quadrants.lang.ops.min


Module Contents
---------------

.. py:function:: cast(obj, dtype)

   Copy and cast a scalar or a matrix to a specified data type.
   Must be called in Quadrants scope.

   :param obj: Input scalar or matrix.
   :type obj: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param dtype: A primitive type defined in :mod:`~quadrants.types.primitive_types`.
   :type dtype: :mod:`~quadrants.types.primitive_types`

   :returns: A copy of `obj`, casted to the specified data type `dtype`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Matrix([0, 1, 2], qd.i32)
       >>>     y = qd.cast(x, qd.f32)
       >>>     print(y)
       >>>
       >>> test()
       [0.0, 1.0, 2.0]


.. py:function:: bit_cast(obj, dtype)

   Copy and cast a scalar to a specified data type with its underlying
   bits preserved. Must be called in quadrants scope.

   This function is equivalent to `reinterpret_cast` in C++.

   :param obj: Input scalar.
   :type obj: :mod:`~quadrants.types.primitive_types`
   :param dtype: Target data type, must have             the same precision bits as the input (hence `f32` -> `f64` is not allowed).
   :type dtype: :mod:`~quadrants.types.primitive_types`

   :returns: A copy of `obj`, casted to the specified data type `dtype`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = 3.14
       >>>     y = qd.bit_cast(x, qd.i32)
       >>>     print(y)  # 1078523331
       >>>
       >>>     z = qd.bit_cast(y, qd.f32)
       >>>     print(z)  # 3.14


.. py:function:: sin(x)

   Trigonometric sine, element-wise.

   :param x: Angle, in radians.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The sine of each element of `x`.

   Example::

       >>> from math import pi
       >>> x = qd.Matrix([-pi/2., 0, pi/2.])
       >>> qd.sin(x)
       [-1., 0., 1.]


.. py:function:: cos(x)

   Trigonometric cosine, element-wise.

   :param x: Angle, in radians.
   :type x: Union[:mod:`~quadrants.type.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The cosine of each element of `x`.

   Example::

       >>> from math import pi
       >>> x = qd.Matrix([-pi, 0, pi/2.])
       >>> qd.cos(x)
       [-1., 1., 0.]


.. py:function:: asin(x)

   Trigonometric inverse sine, element-wise.

   The inverse of `sin` so that, if `y = sin(x)`, then `x = asin(y)`.

   For input `x` not in the domain `[-1, 1]`, this function returns `nan` if         it's called in quadrants scope, or raises exception if it's called in python scope.

   :param x: A scalar or a matrix with elements in [-1, 1].
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The inverse sine of each element in `x`, in radians and in the closed             interval `[-pi/2, pi/2]`.

   Example::

       >>> from math import pi
       >>> qd.asin(qd.Matrix([-1.0, 0.0, 1.0])) * 180 / pi
       [-90., 0., 90.]


.. py:function:: acos(x)

   Trigonometric inverse cosine, element-wise.

   The inverse of `cos` so that, if `y = cos(x)`, then `x = acos(y)`.

   For input `x` not in the domain `[-1, 1]`, this function returns `nan` if         it's called in quadrants scope, or raises exception if it's called in python scope.

   :param x: A scalar or a matrix with elements in [-1, 1].
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The inverse cosine of each element in `x`, in radians and in the closed             interval `[0, pi]`. This is a scalar if `x` is a scalar.

   Example::

       >>> from math import pi
       >>> qd.acos(qd.Matrix([-1.0, 0.0, 1.0])) * 180 / pi
       [180., 90., 0.]


.. py:function:: sqrt(x)

   Return the non-negative square-root of a scalar or a matrix,
   element wise. If `x < 0` an exception is raised.

   :param x: The scalar or matrix whose square-roots are required.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The square-root `y` so that `y >= 0` and `y^2 = x`. `y` has the same type as `x`.

   Example::

       >>> x = qd.Matrix([1., 4., 9.])
       >>> y = qd.sqrt(x)
       >>> y
       [1.0, 2.0, 3.0]


.. py:function:: rsqrt(x)

   The reciprocal of the square root function.

   :param x: A scalar or a matrix.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The reciprocal of `sqrt(x)`.


.. py:function:: round(x, dtype=None)

   Round to the nearest integer, element-wise.

   :param x: A scalar or a matrix.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param dtype: (:mod:`~quadrants.types.primitive_types`): the returned type, default to `None`. If             set to `None` the retuned value will have the same type with `x`.

   :returns: The nearest integer of `x`, with return value type `dtype`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Vector([-1.5, 1.2, 2.7])
       >>>     print(qd.round(x))
       [-2., 1., 3.]


.. py:function:: floor(x, dtype=None)

   Return the floor of the input, element-wise.
   The floor of the scalar `x` is the largest integer `k`, such that `k <= x`.

   :param x: Input scalar or matrix.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param dtype: (:mod:`~quadrants.types.primitive_types`): the returned type, default to `None`. If             set to `None` the retuned value will have the same type with `x`.

   :returns: The floor of each element in `x`, with return value type `dtype`.

   Example::
       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Matrix([-1.1, 2.2, 3.])
       >>>     y = qd.floor(x, qd.f64)
       >>>     print(y)  # [-2.000000000000, 2.000000000000, 3.000000000000]


.. py:function:: ceil(x, dtype=None)

   Return the ceiling of the input, element-wise.

   The ceil of the scalar `x` is the smallest integer `k`, such that `k >= x`.

   :param x: Input scalar or matrix.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param dtype: (:mod:`~quadrants.types.primitive_types`): the returned type, default to `None`. If             set to `None` the retuned value will have the same type with `x`.

   :returns: The ceiling of each element in `x`, with return value type `dtype`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Matrix([3.14, -1.5])
       >>>     y = qd.ceil(x)
       >>>     print(y)  # [4.0, -1.0]


.. py:function:: frexp(x)

.. py:function:: tan(x)

   Trigonometric tangent function, element-wise.

   Equivalent to `qd.sin(x)/qd.cos(x)` element-wise.

   :param x: Input scalar or matrix.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The tangent values of `x`.

   Example::

       >>> from math import pi
       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Matrix([-pi, pi/2, pi])
       >>>     y = qd.tan(x)
       >>>     print(y)
       >>>
       >>> test()
       [-0.0, -22877334.0, 0.0]


.. py:function:: tanh(x)

   Compute the hyperbolic tangent of `x`, element-wise.

   :param x: Input scalar or matrix.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The corresponding hyperbolic tangent values.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Matrix([-1.0, 0.0, 1.0])
       >>>     y = qd.tanh(x)
       >>>     print(y)
       >>>
       >>> test()
       [-0.761594, 0.000000, 0.761594]


.. py:function:: exp(x)

   Compute the exponential of all elements in `x`, element-wise.

   :param x: Input scalar or matrix.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: Element-wise exponential of `x`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Matrix([-1.0, 0.0, 1.0])
       >>>     y = qd.exp(x)
       >>>     print(y)
       >>>
       >>> test()
       [0.367879, 1.000000, 2.718282]


.. py:function:: log(x)

   Compute the natural logarithm, element-wise.

   The natural logarithm `log` is the inverse of the exponential function,
   so that `log(exp(x)) = x`. The natural logarithm is logarithm in base `e`.

   :param x: Input scalar or matrix.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The natural logarithm of `x`, element-wise.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Vector([-1.0, 0.0, 1.0])
       >>>     y = qd.log(x)
       >>>     print(y)
       >>>
       >>> test()
       [-nan, -inf, 0.000000]


.. py:function:: abs(x)

   Compute the absolute value :math:`|x|` of `x`, element-wise.

   :param x: Input scalar or matrix.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The absolute value of each element in `x`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Vector([-1.0, 0.0, 1.0])
       >>>     y = qd.abs(x)
       >>>     print(y)
       >>>
       >>> test()
       [1.0, 0.0, 1.0]


.. py:function:: random(dtype=float) -> Union[float, int]

   Return a single random float/integer according to the specified data type.
   Must be called in quadrants scope.

   If the required `dtype` is float type, this function returns a random number
   sampled from the uniform distribution in the half-open interval [0, 1).

   For integer types this function returns a random integer in the
   half-open interval [0, 2^32) if a 32-bit integer is required,
   or a random integer in the half-open interval [0, 2^64) if a
   64-bit integer is required.

   :param dtype: Type of the required random value.
   :type dtype: :mod:`~quadrants.types.primitive_types`

   :returns: A random value with type `dtype`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.random(float)
       >>>     print(x)  # 0.090257
       >>>
       >>>     y = qd.random(qd.f64)
       >>>     print(y)  # 0.716101627301
       >>>
       >>>     i = qd.random(qd.i32)
       >>>     print(i)  # -963722261
       >>>
       >>>     j = qd.random(qd.i64)
       >>>     print(j)  # 73412986184350777


.. py:function:: pow(base, exponent)

   First array elements raised to second array elements :math:`{base}^{exponent}`, element-wise.

   The result type of two scalar operands is determined as follows:
   - If the exponent is an integral value, then the result type takes the type of the base.
   - Otherwise, the result type follows
     [Implicit type casting in binary operations](https://docs.taichi-lang.org/docs/type#implicit-type-casting-in-binary-operations).

   With the above rules, an integral value raised to a negative integral value cannot have a
   feasible type. Therefore, an exception will be raised if debug mode or optimization passes
   are on; otherwise 1 will be returned.

   In the following situations, the result is undefined:
   - A negative value raised to a non-integral value.
   - A zero value raised to a non-positive value.

   :param base: The bases.
   :type base: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param exponent: The exponents.
   :type exponent: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: `base` raised to `exponent`. This is a scalar if both `base` and `exponent` are scalars.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Matrix([-2.0, 2.0])
       >>>     y = -3
       >>>     z = qd.pow(x, y)
       >>>     print(z)
       >>>
       >>> test()
       [-0.125000, 0.125000]


.. py:function:: atan2(x1, x2)

   Element-wise arc tangent of `x1/x2`.

   :param x1: y-coordinates.
   :type x1: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param x2: x-coordinates.
   :type x2: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: Angles in radians, in the range `[-pi, pi]`.
             This is a scalar if both `x1` and `x2` are scalars.

   Example::

       >>> from math import pi
       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Matrix([-1.0, 1.0, -1.0, 1.0])
       >>>     y = qd.Matrix([-1.0, -1.0, 1.0, 1.0])
       >>>     z = qd.atan2(y, x) * 180 / pi
       >>>     print(z)
       >>>
       >>> test()
       [-135.0, -45.0, 135.0, 45.0]


.. py:function:: raw_div(x1, x2)

   Return `x1 // x2` if both `x1`, `x2` are integers, otherwise return `x1/x2`.

   :param x1: Dividend.
   :type x1: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param x2: Divisor.
   :type x2: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: Return `x1 // x2` if both `x1`, `x2` are integers, otherwise return `x1/x2`.

   Example::

       >>> @qd.kernel
       >>> def main():
       >>>     x = 5
       >>>     y = 3
       >>>     print(raw_div(x, y))  # 1
       >>>     z = 4.0
       >>>     print(raw_div(x, z))  # 1.25


.. py:function:: raw_mod(x1, x2)

   Return the remainder of `x1/x2`, element-wise.
   This is the C-style `mod` function.

   :param x1: The dividend.
   :type x1: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param x2: The divisor.
   :type x2: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The remainder of `x1` divided by `x2`.

   Example::

       >>> @qd.kernel
       >>> def main():
       >>>     print(qd.mod(-4, 3))  # 2
       >>>     print(qd.raw_mod(-4, 3))  # -1


.. py:function:: bit_shr(x1, x2)

   Elements in `x1` shifted to the right by number of bits in `x2`.
   Both `x1`, `x2` must have integer type.

   :param x1: Input data.
   :type x1: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param x2: Number of bits to remove at the right of `x1`.
   :type x2: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: Return `x1` with bits shifted `x2` times to the right.
             This is a scalar if both `x1` and `x2` are scalars.

   Example::
       >>> @qd.kernel
       >>> def main():
       >>>     x = qd.Matrix([7, 8])
       >>>     y = qd.Matrix([1, 2])
       >>>     print(qd.bit_shr(x, y))
       >>>
       >>> main()
       [3, 2]


.. py:function:: select(cond, x1, x2)

   Return an array drawn from elements in `x1` or `x2`,
   depending on the conditions in `cond`.

   :param cond: The array of conditions.
   :type cond: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param x1: The arrays where the output elements are taken from.
   :type x1: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param x2: The arrays where the output elements are taken from.
   :type x2: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The output at position `k` is the k-th element of `x1` if the k-th element
             in `cond` is `True`, otherwise it's the k-th element of `x2`.

   Example::

       >>> @qd.kernel
       >>> def main():
       >>>     cond = qd.Matrix([0, 1, 0, 1])
       >>>     x = qd.Matrix([1, 2, 3, 4])
       >>>     y = qd.Matrix([-1, -2, -3, -4])
       >>>     print(qd.select(cond, x, y))
       >>>
       >>> main()
       [-1, 2, -3, 4]


.. py:function:: atomic_add(x, y)

   Atomically compute `x + y`, store the result in `x`,
   and return the old value of `x`.

   `x` must be a writable target, constant expressions or scalars
   are not allowed.

   :param x: The input.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param y: The input.
   :type y: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The old value of `x`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Vector([0, 0, 0])
       >>>     y = qd.Vector([1, 2, 3])
       >>>     z = qd.atomic_add(x, y)
       >>>     print(x)  # [1, 2, 3]  the new value of x
       >>>     print(z)  # [0, 0, 0], the old value of x
       >>>
       >>>     qd.atomic_add(1, x)  # will raise QuadrantsSyntaxError


.. py:function:: atomic_mul(x, y)

   Atomically compute `x * y`, store the result in `x`,
   and return the old value of `x`.

   `x` must be a writable target, constant expressions or scalars
   are not allowed.

   :param x: The input.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param y: The input.
   :type y: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The old value of `x`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Vector([1, 2, 3])
       >>>     y = qd.Vector([4, 5, 6])
       >>>     z = qd.atomic_mul(x, y)
       >>>     print(x)  # [1, 2, 3]  the new value of x
       >>>     print(z)  # [4, 10, 18], the old value of x
       >>>
       >>>     qd.atomic_mul(1, x)  # will raise QuadrantsSyntaxError


.. py:function:: atomic_sub(x, y)

   Atomically subtract `x` by `y`, store the result in `x`,
   and return the old value of `x`.

   `x` must be a writable target, constant expressions or scalars
   are not allowed.

   :param x: The input.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param y: The input.
   :type y: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The old value of `x`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Vector([0, 0, 0])
       >>>     y = qd.Vector([1, 2, 3])
       >>>     z = qd.atomic_sub(x, y)
       >>>     print(x)  # [-1, -2, -3]  the new value of x
       >>>     print(z)  # [0, 0, 0], the old value of x
       >>>
       >>>     qd.atomic_sub(1, x)  # will raise QuadrantsSyntaxError


.. py:function:: atomic_min(x, y)

   Atomically compute the minimum of `x` and `y`, element-wise.
   Store the result in `x`, and return the old value of `x`.

   `x` must be a writable target, constant expressions or scalars
   are not allowed.

   :param x: The input.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param y: The input.
   :type y: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The old value of `x`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = 2
       >>>     y = 1
       >>>     z = qd.atomic_min(x, y)
       >>>     print(x)  # 1  the new value of x
       >>>     print(z)  # 2, the old value of x
       >>>
       >>>     qd.atomic_min(1, x)  # will raise QuadrantsSyntaxError


.. py:function:: atomic_max(x, y)

   Atomically compute the maximum of `x` and `y`, element-wise.
   Store the result in `x`, and return the old value of `x`.

   `x` must be a writable target, constant expressions or scalars
   are not allowed.

   :param x: The input.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param y: The input.
   :type y: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The old value of `x`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = 1
       >>>     y = 2
       >>>     z = qd.atomic_max(x, y)
       >>>     print(x)  # 2  the new value of x
       >>>     print(z)  # 1, the old value of x
       >>>
       >>>     qd.atomic_max(1, x)  # will raise QuadrantsSyntaxError


.. py:function:: atomic_and(x, y)

   Atomically compute the bit-wise AND of `x` and `y`, element-wise.
   Store the result in `x`, and return the old value of `x`.

   `x` must be a writable target, constant expressions or scalars
   are not allowed.

   :param x: The input. When both are matrices they must have the same shape.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param y: The input. When both are matrices they must have the same shape.
   :type y: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The old value of `x`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Vector([-1, 0, 1])
       >>>     y = qd.Vector([1, 2, 3])
       >>>     z = qd.atomic_and(x, y)
       >>>     print(x)  # [1, 0, 1]  the new value of x
       >>>     print(z)  # [-1, 0, 1], the old value of x
       >>>
       >>>     qd.atomic_and(1, x)  # will raise QuadrantsSyntaxError


.. py:function:: atomic_or(x, y)

   Atomically compute the bit-wise OR of `x` and `y`, element-wise.
   Store the result in `x`, and return the old value of `x`.

   `x` must be a writable target, constant expressions or scalars
   are not allowed.

   :param x: The input. When both are matrices they must have the same shape.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param y: The input. When both are matrices they must have the same shape.
   :type y: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The old value of `x`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Vector([-1, 0, 1])
       >>>     y = qd.Vector([1, 2, 3])
       >>>     z = qd.atomic_or(x, y)
       >>>     print(x)  # [-1, 2, 3]  the new value of x
       >>>     print(z)  # [-1, 0, 1], the old value of x
       >>>
       >>>     qd.atomic_or(1, x)  # will raise QuadrantsSyntaxError


.. py:function:: atomic_xor(x, y)

   Atomically compute the bit-wise XOR of `x` and `y`, element-wise.
   Store the result in `x`, and return the old value of `x`.

   `x` must be a writable target, constant expressions or scalars
   are not allowed.

   :param x: The input. When both are matrices they must have the same shape.
   :type x: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]
   :param y: The input. When both are matrices they must have the same shape.
   :type y: Union[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]

   :returns: The old value of `x`.

   Example::

       >>> @qd.kernel
       >>> def test():
       >>>     x = qd.Vector([-1, 0, 1])
       >>>     y = qd.Vector([1, 2, 3])
       >>>     z = qd.atomic_xor(x, y)
       >>>     print(x)  # [-2, 2, 2]  the new value of x
       >>>     print(z)  # [-1, 0, 1], the old value of x
       >>>
       >>>     qd.atomic_xor(1, x)  # will raise QuadrantsSyntaxError


.. py:function:: max(*args)

   Compute the maximum of the arguments, element-wise.

   This function takes no effect on a single argument, even it's array-like.
   When there are both scalar and matrix arguments in `args`, the matrices
   must have the same shape, and scalars will be broadcasted to the same shape as the matrix.

   :param args: (List[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]):             The input.

   :returns: Maximum of the inputs.

   Example::

       >>> @qd.kernel
       >>> def foo():
       >>>     x = qd.Vector([0, 1, 2])
       >>>     y = qd.Vector([3, 4, 5])
       >>>     z = qd.max(x, y, 4)
       >>>     print(z)  # [4, 4, 5]


.. py:function:: min(*args)

   Compute the minimum of the arguments, element-wise.

   This function takes no effect on a single argument, even it's array-like.
   When there are both scalar and matrix arguments in `args`, the matrices
   must have the same shape, and scalars will be broadcasted to the same shape as the matrix.

   :param args: (List[:mod:`~quadrants.types.primitive_types`, :class:`~quadrants.Matrix`]):             The input.

   :returns: Minimum of the inputs.

   Example::

       >>> @qd.kernel
       >>> def foo():
       >>>     x = qd.Vector([0, 1, 2])
       >>>     y = qd.Vector([3, 4, 5])
       >>>     z = qd.min(x, y, 1)
       >>>     print(z)  # [0, 1, 1]


